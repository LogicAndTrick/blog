import{o as n,c as t,a,b as e}from"./app.9075578a.js";const s='{"title":"The Overlapping Date Range Test","description":"","frontmatter":{"date":"2013-09-17T12:00:00.000Z","category":"Programming","tags":["programming","algorithms"],"title":"The Overlapping Date Range Test"},"headers":[{"level":2,"title":"A Visualisation of the Problem","slug":"a-visualisation-of-the-problem"},{"level":2,"title":"How Not To Do It","slug":"how-not-to-do-it"},{"level":3,"title":"Example 1","slug":"example-1"},{"level":3,"title":"Example 2","slug":"example-2"},{"level":2,"title":"Deriving the Solution","slug":"deriving-the-solution"}],"relativePath":"page/the-overlapping-date-range-test.md","lastUpdated":1611625840308}',o={},l=a("p",null,[e("In my line of work, I have to do a "),a("strong",null,"lot"),e(" of comparisons of times and dates. The most common use is something like this:")],-1),p=a("ol",null,[a("li",null,"Given a date range selected by the user (say, one week),"),a("li",null,"Get all the periods (from a database or other data source) that overlap with that date range,"),a("li",null,"Where every period has an explicit start and end time.")],-1),i=a("p",null,"Simple, right? Well, perhaps not as simple as you might think. I've seen this test performed incorrectly many times, even by experienced programmers. This problem has a very elegant and robust solution, but it is not immediately obvious to most people.",-1),c=a("h2",{id:"a-visualisation-of-the-problem"},[a("a",{class:"header-anchor",href:"#a-visualisation-of-the-problem","aria-hidden":"true"},"#"),e(" A Visualisation of the Problem")],-1),r=a("p",null,"When this problem crops up for me (which is quite often), I draw a diagram. Imagine that the selected time range and the periods to match against are drawn as timelines. There are six different situations that can arise:",-1),u=a("div",{class:"image center"},[a("img",{src:"/assets/OverlappingDateRangeDiagram.cbc1be21.png",alt:"Time period overlap test"}),e(" A timeline diagram of the six scenarios of this problem. ")],-1),d=a("ol",null,[a("li",null,"The period is entirely before the selected range (does not match)"),a("li",null,"The period is entirely after the selected range (does not match)"),a("li",null,"The period starts before the selected range, and ends during the selected range (match)"),a("li",null,"The period starts and ends during the selected range (match)"),a("li",null,"The period starts during the selected range, and ends after the selected range (match)"),a("li",null,"The period starts before the selected range, and ends after the selected range (match)")],-1),k=a("h2",{id:"how-not-to-do-it"},[a("a",{class:"header-anchor",href:"#how-not-to-do-it","aria-hidden":"true"},"#"),e(" How Not To Do It")],-1),h=a("p",null,"First of all, some examples of how not to do it. I pulled these examples from production code, written by experienced programmers. I say this not to point out any lack of skill, but rather how easy it is to do it wrong.",-1),m=a("h3",{id:"example-1"},[a("a",{class:"header-anchor",href:"#example-1","aria-hidden":"true"},"#"),e(" Example 1")],-1),g=a("div",{class:"language-csharp"},[a("pre",null,[a("code",null,[a("span",{class:"token keyword"},"if"),e(),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},"("),e("period"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"<="),e(" selection"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"&&"),e(" period"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},">"),e(" selection"),a("span",{class:"token punctuation"},"."),e("End"),a("span",{class:"token punctuation"},")"),e(),a("span",{class:"token operator"},"||"),e("\n    "),a("span",{class:"token punctuation"},"("),e("period"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},">="),e(" selection"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"&&"),e(" period"),a("span",{class:"token punctuation"},"."),e("End "),a("span",{class:"token operator"},"<="),e(" selection"),a("span",{class:"token punctuation"},"."),e("End"),a("span",{class:"token punctuation"},")"),e(),a("span",{class:"token operator"},"||"),e("\n    "),a("span",{class:"token punctuation"},"("),e("period"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"<"),e(" selection"),a("span",{class:"token punctuation"},"."),e("End "),a("span",{class:"token operator"},"&&"),e(" period"),a("span",{class:"token punctuation"},"."),e("End "),a("span",{class:"token operator"},">="),e(" selection"),a("span",{class:"token punctuation"},"."),e("End"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},")"),e("\n"),a("span",{class:"token punctuation"},"{"),e("\n    "),a("span",{class:"token comment"},"// period overlaps selection"),e("\n"),a("span",{class:"token punctuation"},"}"),e("\n")])])],-1),f=a("h3",{id:"example-2"},[a("a",{class:"header-anchor",href:"#example-2","aria-hidden":"true"},"#"),e(" Example 2")],-1),v=a("div",{class:"language-csharp"},[a("pre",null,[a("code",null,[a("span",{class:"token class-name"},[a("span",{class:"token keyword"},"var")]),e(" matching "),a("span",{class:"token operator"},"="),e(" periods"),a("span",{class:"token punctuation"},"."),a("span",{class:"token function"},"Where"),a("span",{class:"token punctuation"},"("),e("period "),a("span",{class:"token operator"},"=>"),e(" \n    "),a("span",{class:"token punctuation"},"("),e("period"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},">="),e(" selection"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"&&"),e(" period"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"<="),e(" selection"),a("span",{class:"token punctuation"},"."),e("End"),a("span",{class:"token punctuation"},")"),e(),a("span",{class:"token operator"},"||"),e(" \n    "),a("span",{class:"token punctuation"},"("),e("period"),a("span",{class:"token punctuation"},"."),e("End "),a("span",{class:"token operator"},">="),e(" selection"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"&&"),e(" period"),a("span",{class:"token punctuation"},"."),e("End "),a("span",{class:"token operator"},"<="),e(" selection"),a("span",{class:"token punctuation"},"."),e("End"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},";"),e("\n")])])],-1),w=a("p",null,"The first thing you might notice about these examples is that they seem rather complex. Both examples get pretty close, but fail to match on one of the conditions from the diagram above. Example 1 fails on scenario 3, and example 2 fails on scenario 6.",-1),b=a("h2",{id:"deriving-the-solution"},[a("a",{class:"header-anchor",href:"#deriving-the-solution","aria-hidden":"true"},"#"),e(" Deriving the Solution")],-1),y=a("p",null,"Both of the examples above fail one test case each, so they could both be resolved by adding a new OR statement to the conditions in each. However, that's not the best solution to this problem. By looking at the problem a bit closer, it's possible to derive a clean solution that's very easy to remember. (Note: For simplicity, I'm going to ignore the case where the times are equal. Changing these examples to and from inclusive/exclusive algorithms is left as an exercise for the reader.)",-1),x=a("p",null,"We start by looking at the six requirements. Since we know that four scenarios must match and two must not, we can build a brute-force solution:",-1),S=a("div",{class:"language-csharp"},[a("pre",null,[a("code",null,[a("span",{class:"token keyword"},"if"),e(),a("span",{class:"token punctuation"},"("),e("Condition3 OR Condition4 OR Condition5 "),a("span",{class:"token class-name"},"OR"),e(" Condition6"),a("span",{class:"token punctuation"},")"),e("\n"),a("span",{class:"token punctuation"},"{"),e("\n    "),a("span",{class:"token comment"},"// period overlaps selection"),e("\n"),a("span",{class:"token punctuation"},"}"),e("\n")])])],-1),E=a("p",null,"Or, in actual code:",-1),T=a("div",{class:"language-csharp"},[a("pre",null,[a("code",null,[a("span",{class:"token keyword"},"if"),e(),a("span",{class:"token punctuation"},"("),a("span",{class:"token punctuation"},"("),e("period"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"<"),e(" selection"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"&&"),e(" period"),a("span",{class:"token punctuation"},"."),e("End "),a("span",{class:"token operator"},">"),e(" selection"),a("span",{class:"token punctuation"},"."),e("Start"),a("span",{class:"token punctuation"},")"),e(),a("span",{class:"token operator"},"||"),e("\n    "),a("span",{class:"token punctuation"},"("),e("period"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},">"),e(" selection"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"&&"),e(" period"),a("span",{class:"token punctuation"},"."),e("End "),a("span",{class:"token operator"},"<"),e(" selection"),a("span",{class:"token punctuation"},"."),e("End"),a("span",{class:"token punctuation"},")"),e(),a("span",{class:"token operator"},"||"),e("\n    "),a("span",{class:"token punctuation"},"("),e("period"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"<"),e(" selection"),a("span",{class:"token punctuation"},"."),e("End "),a("span",{class:"token operator"},"&&"),e(" period"),a("span",{class:"token punctuation"},"."),e("End "),a("span",{class:"token operator"},">"),e(" selection"),a("span",{class:"token punctuation"},"."),e("End"),a("span",{class:"token punctuation"},")"),e(),a("span",{class:"token operator"},"||"),e("\n    "),a("span",{class:"token punctuation"},"("),e("period"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"<"),e(" selection"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"&&"),e(" period"),a("span",{class:"token punctuation"},"."),e("End "),a("span",{class:"token operator"},">"),e(" selection"),a("span",{class:"token punctuation"},"."),e("End"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},")"),e("\n"),a("span",{class:"token punctuation"},"{"),e("\n    "),a("span",{class:"token comment"},"// period overlaps selection"),e("\n"),a("span",{class:"token punctuation"},"}"),e("\n")])])],-1),I=a("p",null,"This code should work and will pass all tests - however, it's complex and unwieldy. I cannot say for sure that it doesn't have any bugs without running unit tests over it, and I triple-checked it after writing it just now. It's not very nice code, so we should try to optimise it if we can.",-1),O=a("p",null,"Let's look at this a different way. If we have six scenarios and 4 are valid, then the other 2 are invalid. So, instead of explicitly looking for the valid situations, we can instead get rid of the invalid ones. Like so:",-1),D=a("div",{class:"language-csharp"},[a("pre",null,[a("code",null,[a("span",{class:"token keyword"},"if"),e(),a("span",{class:"token punctuation"},"("),a("span",{class:"token function"},"NOT"),a("span",{class:"token punctuation"},"("),e("Condition1 "),a("span",{class:"token class-name"},"OR"),e(" Condition2"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},")"),e("\n"),a("span",{class:"token punctuation"},"{"),e("\n    "),a("span",{class:"token comment"},"// period overlaps selection"),e("\n"),a("span",{class:"token punctuation"},"}"),e("\n")])])],-1),R=a("p",null,"Implemented in code:",-1),A=a("div",{class:"language-csharp"},[a("pre",null,[a("code",null,[a("span",{class:"token keyword"},"if"),e(),a("span",{class:"token punctuation"},"("),a("span",{class:"token operator"},"!"),a("span",{class:"token punctuation"},"("),e("\n    "),a("span",{class:"token punctuation"},"("),e("period"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"<"),e(" selection"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"&&"),e(" period"),a("span",{class:"token punctuation"},"."),e("End "),a("span",{class:"token operator"},"<"),e(" selection"),a("span",{class:"token punctuation"},"."),e("Start"),a("span",{class:"token punctuation"},")"),e(),a("span",{class:"token operator"},"||"),e("\n    "),a("span",{class:"token punctuation"},"("),e("period"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},">"),e(" selection"),a("span",{class:"token punctuation"},"."),e("End "),a("span",{class:"token operator"},"&&"),e(" period"),a("span",{class:"token punctuation"},"."),e("End "),a("span",{class:"token operator"},">"),e(" selection"),a("span",{class:"token punctuation"},"."),e("End"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},")"),e("\n"),a("span",{class:"token punctuation"},")"),e("\n"),a("span",{class:"token punctuation"},"{"),e("\n    "),a("span",{class:"token comment"},"// period overlaps selection"),e("\n"),a("span",{class:"token punctuation"},"}"),e("\n")])])],-1),N=a("p",null,"This is better, but can be improved. Since we know that a period start is always before the period end, we can exclude the extra comparisons:",-1),C=a("div",{class:"language-csharp"},[a("pre",null,[a("code",null,[a("span",{class:"token keyword"},"if"),e(),a("span",{class:"token punctuation"},"("),a("span",{class:"token operator"},"!"),a("span",{class:"token punctuation"},"("),e("period"),a("span",{class:"token punctuation"},"."),e("End "),a("span",{class:"token operator"},"<"),e(" selection"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"||"),e(" period"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},">"),e(" selection"),a("span",{class:"token punctuation"},"."),e("End"),a("span",{class:"token punctuation"},")"),a("span",{class:"token punctuation"},")"),e("\n"),a("span",{class:"token punctuation"},"{"),e("\n    "),a("span",{class:"token comment"},"// period overlaps selection"),e("\n"),a("span",{class:"token punctuation"},"}"),e("\n")])])],-1),B=a("p",null,[e("This is starting to look much better, and one small change simplifies it further. Since binary logic states that "),a("strong",null,"NOT(A OR B)"),e(" is equivalent to "),a("strong",null,"NOT(A) AND NOT(B)"),e(", we can make this change:")],-1),W=a("div",{class:"language-csharp"},[a("pre",null,[a("code",null,[a("span",{class:"token keyword"},"if"),e(),a("span",{class:"token punctuation"},"("),e("period"),a("span",{class:"token punctuation"},"."),e("End "),a("span",{class:"token operator"},">"),e(" selection"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"&&"),e(" period"),a("span",{class:"token punctuation"},"."),e("Start "),a("span",{class:"token operator"},"<"),e(" selection"),a("span",{class:"token punctuation"},"."),e("End"),a("span",{class:"token punctuation"},")"),e("\n"),a("span",{class:"token punctuation"},"{"),e("\n    "),a("span",{class:"token comment"},"// period overlaps selection"),e("\n"),a("span",{class:"token punctuation"},"}"),e("\n")])])],-1),q=a("p",null,[e("...and now we have a simple solution that covers all use cases. The code is easy to maintain and read. It also lets us explain the algorithm in clear English: "),a("strong",null,"A period overlaps a selected date range when it ends after the selected start date and starts before the selected end date."),e(" As an added bonus, this method works for any sortable value, not just dates.")],-1);o.render=function(a,e,s,o,P,j){return n(),t("div",null,[l,p,i,c,r,u,d,k,h,m,g,f,v,w,b,y,x,S,E,T,I,O,D,R,A,N,C,B,W,q])};export default o;export{s as __pageData};
