<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>
      The Overlapping Date Range Test | Logic & Trick
    </title>
    <meta name="description" content="Logic & Trick blog">
    <link rel="stylesheet" href="/assets/style.d1fea7dc.css">
    <link rel="modulepreload" href="/assets/Home.a3fa664e.js">
    <link rel="modulepreload" href="/assets/app.9075578a.js">
    <link rel="modulepreload" href="/assets/page_the-overlapping-date-range-test.md.0735ccac.lean.js">
    <link rel="modulepreload" href="/assets/app.9075578a.js">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
  </head>
  <body>
    <div id="app"><!--[--><div class="no-sidebar theme"><header class="nav-bar" data-v-676b1c4e><div class="nav-wrapper" data-v-676b1c4e><a class="nav-bar-title" href="/" data-v-676b1c4e><img class="logo" src="/lnt_logo_2013.png" alt="{{ $site.title }}" data-v-676b1c4e></a><div class="flex-grow" data-v-676b1c4e></div><div class="nav" data-v-676b1c4e><span data-v-676b1c4e>© Logic &amp; Trick 2021</span><span class="splitter" data-v-676b1c4e>•</span><a href="https://github.com/LogicAndTrick" data-v-676b1c4e>Github</a><span class="splitter" data-v-676b1c4e>•</span><a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" data-v-676b1c4e><img alt="Creative Commons License" src="/cc-by-nc-nd.png" data-v-676b1c4e></a></div></div></header><aside class="sidebar" data-v-02743965><!--[--><!--]--><p class="sidebar-header" data-v-02743965>The Overlapping Date Range Test</p><ul class="sidebar-links" data-v-02743965><!--[--><li class="sidebar-link" data-v-02743965 data-v-02743965><a class="sidebar-link-item" href="#a-visualisation-of-the-problem" data-v-02743965>A Visualisation of the Problem</a><!----></li><li class="sidebar-link" data-v-02743965 data-v-02743965><a class="sidebar-link-item" href="#how-not-to-do-it" data-v-02743965>How Not To Do It</a><ul class="sidebar-links" data-v-02743965><li class="sidebar-link" data-v-02743965 data-v-02743965><a class="sidebar-link-item" href="#example-1" data-v-02743965>Example 1</a><!----></li><li class="sidebar-link" data-v-02743965 data-v-02743965><a class="sidebar-link-item" href="#example-2" data-v-02743965>Example 2</a><!----></li></ul></li><li class="sidebar-link" data-v-02743965 data-v-02743965><a class="sidebar-link-item" href="#deriving-the-solution" data-v-02743965>Deriving the Solution</a><!----></li><!--]--></ul><!--[--><!--]--></aside><!-- TODO: make this button accessible --><div class="sidebar-mask"></div><main class="page" data-v-558e9244><div class="container" data-v-558e9244><div class="content" data-v-558e9244><h1 class="page-title" data-v-558e9244>The Overlapping Date Range Test</h1><div class="page-info" data-v-558e9244>First posted on September 17, 2013 in Programming</div><div data-v-558e9244><p>In my line of work, I have to do a <strong>lot</strong> of comparisons of times and dates. The most common use is something like this:</p><ol><li>Given a date range selected by the user (say, one week),</li><li>Get all the periods (from a database or other data source) that overlap with that date range,</li><li>Where every period has an explicit start and end time.</li></ol><p>Simple, right? Well, perhaps not as simple as you might think. I&#39;ve seen this test performed incorrectly many times, even by experienced programmers. This problem has a very elegant and robust solution, but it is not immediately obvious to most people.</p><h2 id="a-visualisation-of-the-problem"><a class="header-anchor" href="#a-visualisation-of-the-problem" aria-hidden="true">#</a> A Visualisation of the Problem</h2><p>When this problem crops up for me (which is quite often), I draw a diagram. Imagine that the selected time range and the periods to match against are drawn as timelines. There are six different situations that can arise:</p><div class="image center"><img src="/assets/OverlappingDateRangeDiagram.cbc1be21.png" alt="Time period overlap test"> A timeline diagram of the six scenarios of this problem. </div><ol><li>The period is entirely before the selected range (does not match)</li><li>The period is entirely after the selected range (does not match)</li><li>The period starts before the selected range, and ends during the selected range (match)</li><li>The period starts and ends during the selected range (match)</li><li>The period starts during the selected range, and ends after the selected range (match)</li><li>The period starts before the selected range, and ends after the selected range (match)</li></ol><h2 id="how-not-to-do-it"><a class="header-anchor" href="#how-not-to-do-it" aria-hidden="true">#</a> How Not To Do It</h2><p>First of all, some examples of how not to do it. I pulled these examples from production code, written by experienced programmers. I say this not to point out any lack of skill, but rather how easy it is to do it wrong.</p><h3 id="example-1"><a class="header-anchor" href="#example-1" aria-hidden="true">#</a> Example 1</h3><div class="language-csharp"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>period<span class="token punctuation">.</span>Start <span class="token operator">&lt;=</span> selection<span class="token punctuation">.</span>Start <span class="token operator">&amp;&amp;</span> period<span class="token punctuation">.</span>Start <span class="token operator">&gt;</span> selection<span class="token punctuation">.</span>End<span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token punctuation">(</span>period<span class="token punctuation">.</span>Start <span class="token operator">&gt;=</span> selection<span class="token punctuation">.</span>Start <span class="token operator">&amp;&amp;</span> period<span class="token punctuation">.</span>End <span class="token operator">&lt;=</span> selection<span class="token punctuation">.</span>End<span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token punctuation">(</span>period<span class="token punctuation">.</span>Start <span class="token operator">&lt;</span> selection<span class="token punctuation">.</span>End <span class="token operator">&amp;&amp;</span> period<span class="token punctuation">.</span>End <span class="token operator">&gt;=</span> selection<span class="token punctuation">.</span>End<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// period overlaps selection</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="example-2"><a class="header-anchor" href="#example-2" aria-hidden="true">#</a> Example 2</h3><div class="language-csharp"><pre><code><span class="token class-name"><span class="token keyword">var</span></span> matching <span class="token operator">=</span> periods<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>period <span class="token operator">=&gt;</span> 
    <span class="token punctuation">(</span>period<span class="token punctuation">.</span>Start <span class="token operator">&gt;=</span> selection<span class="token punctuation">.</span>Start <span class="token operator">&amp;&amp;</span> period<span class="token punctuation">.</span>Start <span class="token operator">&lt;=</span> selection<span class="token punctuation">.</span>End<span class="token punctuation">)</span> <span class="token operator">||</span> 
    <span class="token punctuation">(</span>period<span class="token punctuation">.</span>End <span class="token operator">&gt;=</span> selection<span class="token punctuation">.</span>Start <span class="token operator">&amp;&amp;</span> period<span class="token punctuation">.</span>End <span class="token operator">&lt;=</span> selection<span class="token punctuation">.</span>End<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>The first thing you might notice about these examples is that they seem rather complex. Both examples get pretty close, but fail to match on one of the conditions from the diagram above. Example 1 fails on scenario 3, and example 2 fails on scenario 6.</p><h2 id="deriving-the-solution"><a class="header-anchor" href="#deriving-the-solution" aria-hidden="true">#</a> Deriving the Solution</h2><p>Both of the examples above fail one test case each, so they could both be resolved by adding a new OR statement to the conditions in each. However, that&#39;s not the best solution to this problem. By looking at the problem a bit closer, it&#39;s possible to derive a clean solution that&#39;s very easy to remember. (Note: For simplicity, I&#39;m going to ignore the case where the times are equal. Changing these examples to and from inclusive/exclusive algorithms is left as an exercise for the reader.)</p><p>We start by looking at the six requirements. Since we know that four scenarios must match and two must not, we can build a brute-force solution:</p><div class="language-csharp"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span>Condition3 OR Condition4 OR Condition5 <span class="token class-name">OR</span> Condition6<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// period overlaps selection</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Or, in actual code:</p><div class="language-csharp"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>period<span class="token punctuation">.</span>Start <span class="token operator">&lt;</span> selection<span class="token punctuation">.</span>Start <span class="token operator">&amp;&amp;</span> period<span class="token punctuation">.</span>End <span class="token operator">&gt;</span> selection<span class="token punctuation">.</span>Start<span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token punctuation">(</span>period<span class="token punctuation">.</span>Start <span class="token operator">&gt;</span> selection<span class="token punctuation">.</span>Start <span class="token operator">&amp;&amp;</span> period<span class="token punctuation">.</span>End <span class="token operator">&lt;</span> selection<span class="token punctuation">.</span>End<span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token punctuation">(</span>period<span class="token punctuation">.</span>Start <span class="token operator">&lt;</span> selection<span class="token punctuation">.</span>End <span class="token operator">&amp;&amp;</span> period<span class="token punctuation">.</span>End <span class="token operator">&gt;</span> selection<span class="token punctuation">.</span>End<span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token punctuation">(</span>period<span class="token punctuation">.</span>Start <span class="token operator">&lt;</span> selection<span class="token punctuation">.</span>Start <span class="token operator">&amp;&amp;</span> period<span class="token punctuation">.</span>End <span class="token operator">&gt;</span> selection<span class="token punctuation">.</span>End<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// period overlaps selection</span>
<span class="token punctuation">}</span>
</code></pre></div><p>This code should work and will pass all tests - however, it&#39;s complex and unwieldy. I cannot say for sure that it doesn&#39;t have any bugs without running unit tests over it, and I triple-checked it after writing it just now. It&#39;s not very nice code, so we should try to optimise it if we can.</p><p>Let&#39;s look at this a different way. If we have six scenarios and 4 are valid, then the other 2 are invalid. So, instead of explicitly looking for the valid situations, we can instead get rid of the invalid ones. Like so:</p><div class="language-csharp"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">NOT</span><span class="token punctuation">(</span>Condition1 <span class="token class-name">OR</span> Condition2<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// period overlaps selection</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Implemented in code:</p><div class="language-csharp"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span>period<span class="token punctuation">.</span>Start <span class="token operator">&lt;</span> selection<span class="token punctuation">.</span>Start <span class="token operator">&amp;&amp;</span> period<span class="token punctuation">.</span>End <span class="token operator">&lt;</span> selection<span class="token punctuation">.</span>Start<span class="token punctuation">)</span> <span class="token operator">||</span>
    <span class="token punctuation">(</span>period<span class="token punctuation">.</span>Start <span class="token operator">&gt;</span> selection<span class="token punctuation">.</span>End <span class="token operator">&amp;&amp;</span> period<span class="token punctuation">.</span>End <span class="token operator">&gt;</span> selection<span class="token punctuation">.</span>End<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// period overlaps selection</span>
<span class="token punctuation">}</span>
</code></pre></div><p>This is better, but can be improved. Since we know that a period start is always before the period end, we can exclude the extra comparisons:</p><div class="language-csharp"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>period<span class="token punctuation">.</span>End <span class="token operator">&lt;</span> selection<span class="token punctuation">.</span>Start <span class="token operator">||</span> period<span class="token punctuation">.</span>Start <span class="token operator">&gt;</span> selection<span class="token punctuation">.</span>End<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// period overlaps selection</span>
<span class="token punctuation">}</span>
</code></pre></div><p>This is starting to look much better, and one small change simplifies it further. Since binary logic states that <strong>NOT(A OR B)</strong> is equivalent to <strong>NOT(A) AND NOT(B)</strong>, we can make this change:</p><div class="language-csharp"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span>period<span class="token punctuation">.</span>End <span class="token operator">&gt;</span> selection<span class="token punctuation">.</span>Start <span class="token operator">&amp;&amp;</span> period<span class="token punctuation">.</span>Start <span class="token operator">&lt;</span> selection<span class="token punctuation">.</span>End<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// period overlaps selection</span>
<span class="token punctuation">}</span>
</code></pre></div><p>...and now we have a simple solution that covers all use cases. The code is easy to maintain and read. It also lets us explain the algorithm in clear English: <strong>A period overlaps a selected date range when it ends after the selected start date and starts before the selected end date.</strong> As an added bonus, this method works for any sortable value, not just dates.</p></div><!----></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"030421b3\",\"page_decal-rendering-in-sledge.md\":\"a8cde558\",\"page_genre-wars-fantasy-and-sci-fi.md\":\"6541200c\",\"page_tales-of-war.md\":\"c3e8529f\",\"page_the-overlapping-date-range-test.md\":\"0735ccac\"}")</script>
    <script type="module" async src="/assets/app.9075578a.js"></script>
  </body>
</html>